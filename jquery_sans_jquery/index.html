<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>jQuery sans jQuery</title>

		<meta name="description" content="jQuery sans jQuery">
		<meta name="author" content="Raphaël Rougeron">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">
        <link rel="stylesheet" href="css/custom.css">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->

        <script src="js/polymer-v0.0.20131003.min.js"></script>
        <link rel="import" href="browser-compat-component.html">
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

				<section>
                    <h1>jQuery sans jQuery</h1>
                     
                    <p>
                        <small>Raphaël Rougeron / <a href="http://twitter.com/goldoraf">@goldoraf</a></small>
                    </p>
                </section>

                <section>
                    <h2>JavaScript il y a 10 ans</h2>
                    <img class="raw" src="images/meh.jpg" />
                    <aside class="notes">
                        Firefox vient de sortir, il s'appelle encore Phoenix. IE6 possède 97% des parts de marché. Rails, Django, Symfony n'existent pas. Le terme Ajax n'est pas encore utilisé (2005). C'est l'époque du DHTML et des scripts copiés/collés, du JS spécifique IE6, ActiveX et autres..., de W3schools comme référence (trouver une image via the internet archive ?)
                    </aside>
                </section>

                <section>
                    <h2>2006</h2>
                    <img class="raw" src="images/jquery_logo.png" />
                    <aside class="notes">
                        Et puis en janvier 2006 apparait jQuery. Même si d'autres librairies sont arrivées avant, comme Prototype, jQuery a sans doute été le vrai déclencheur du renouveau de JS. Avec jQuery, manipuler le DOM ou faire des requêtes Ajax devient facile. jQuery abstrait parfaitement les différences d'impl. des navigateurs.
                    </aside>
                </section>

                <section>
                    <h2>jQuery aujourd'hui</h2>
                    <p style="font-size: 300%">
                        92,2%
                    </p>
                    <aside class="notes">
                        Inclus sur 92,2% des sites utilisant une lib JS, soit 56,2% des sites web... (version 1.x : 99,6%)
                        Il y a 3 fois plus de sites utilisant jQuery que de sites utilisant Flash...
                        C'est remarquable... Et un peu inquiétant : on a le sentiment qu'inclure Jquery est devenu un réflexe, qu'on n'y pense même plus. Enormément de libs et même de frameworks dépendent de jQuery, parfois pour pas grand chose, et alors que jQuery peut être lourd sur, par exemple, un smartphone dont les perfs des navigateurs sont bien inférieures pour des raisons notamment d'architecture CPU. Et on arrive à ce genre de choses...
                    </aside>
                </section>

                <section>
                    <img src="images/job.png" />
                    <aside class="notes">
                         utiliser jQuery, ce n’est pas apprendre/connaitre le JS et les APIs standards ; or JS est déjà partout, et ce n’est pas prêt de changer : si vous êtes développeur web, vous devez connaitre JS car on peut dire qu’il est là pour au moins 10 ans (certes, il y a les initiatives Dart, Typescript, langages qui compilent en JS, qui sont là car pour continuer à améliorer les perfs il faut un langage typé statiquement. Mais tant qu’un standard n’a pas émergé, nous continuerons à utiliser JS). 
                    </aside>
                </section>

                <section>
                    <img class="raw" src="images/html5.png" />
                    <aside class="notes">
                        Et surtout, l'écosystème des navigateurs a considérablement évolué en 10 ans : les browsers récents (IE compris) sont beaucoup plus proches des standrads du W3C, et le besoin d'une couche de compatibilité se fait de moins en moins sentir. Aussi, compte tenu de l'efficacité du code JS pur par rapport à du jQuery, à chaque fois que vous avez la possibilité de vous reposer sur des APIs standards, faites-le ! C'est après tout l'idée derrière HTML5 : standardiser et donner accès à un jeu d'APIs riches et adaptées aux besoins modernes (géolocalisation, gestion de la batterie, etc...)
                    </aside>
                </section>

                <section>
                    <img class="raw" src="images/velos.jpg" />
                    <aside class="notes">
                        Il est clair que ces APIs ne sont pas toujours simples à utiliser (ex. API DnD), et qu'il reste des subtiles différences de comportement entre les navigateurs, mais alors qu'avec jQuery vous allez aller plus vite, sans, vous allez prendre des gamelles, mais vous allez petit à petit apprendre l'équilibre et donc à vraiment faire du vélo ;) Le pb est que cela vous prendra un peu de temps, et étant donné qu'un projet de dev a des ressources (humaines/temps) limitées, il est très important d'établir une stratégie en début de projet.
                    </aside>
                </section>

                <section>
                    <img src="images/support_matrix.jpg" />
                    <aside class="notes">
                        Cette stratégie nécessite tout d'abord de déterminer les navigateurs que vous souhaitez/devez supporter. Si vous choisissez la voie du JS pur, chaque browser supporté implique potentiellement de passer du temps à contourner ses bugs spécifiques et à tester sur celui-ci, et naturellement les browsers anciens vont demander bcp plus de temps que les autres. Vous devez donc choisir sur quels browsers l'appli sera totalement supportée, sur quels browsers elle sera supportée mais avec dégradation gracieuse, et sur quels browsers elle ne sera pas supportée. C'est une affaire de compromis.
                        Si vous devez supporter IE6 ou même 7, je vous recommande de conserver jQuery. C'est à partir d'IE8 que la question se pose réellement. S'il s'agit d'un projet simple avec du PE, vous pouvez tenter sans jQuery. De toute façon, je vous déconseille d'essayer de supporter IE8 pour une appli JS complexe (trop lent). A partir d'IE9, vous pouvez très raisonnablement espérer vous en sortir sans jQuery, même pour une appli complexe.
                    </aside>
                </section>

                <section>
                    <img src="images/crash_test.jpg" />
                    <aside class="notes">
                        L'approche sans jQuery nécessite également une approche orientée tests très rigoureuse. Vous devez absolument disposer de tests automatisés exécutables sur tous les browsers supportés ou, à défaut pour certains, d'une checklist de tests manuels. Pensez également à faire des tests de performances, surtout sous IE !!!
                    </aside>
                </section>

                <section>
                    <h2>Polyfilling</h2>
                    <pre><code class="javascript"data-trim contenteditable>
if ('querySelector' in document && 
    'localStorage' in window && 
    'addEventListener' in window) {
    // Go!
} else {
    // Polyfill all the things...
}
                    </code></pre>
                    <aside class="notes">
                        Dans certains cas, l'implémentation de certaines APIs dans un ou plusieurs browsers ne sera pas conforme au standard. On utilisera donc un polyfill, c.a.d une petite lib qui corrige/complète l'implémentation native. On aura alors recours à ce genre de tests pour déterminer s'il faut polyfiller.
                    </aside>
                </section>

                <section>
                    <img class="raw" src="images/modernizr.png" />
                    <aside class="notes">
                        Ou alors vous pouvez utiliser Modernizr, qui fait ce genre de tests pour vous très facilement.
                    </aside>
                </section>

                <section>
                    <h2>Modernizr</h2>
                    <pre><code class="javascript"data-trim contenteditable>
if (Modernizr.localStorage) {
   // Go!
} else {
   // Polyfill all the things...
}
                    </code></pre>
                    <aside class="notes">
                        Bien, il est temps maintenant de répondre à la question : comment se passer de jQuery ?
                    </aside>
                </section>

                <section>
                    <img src="images/jquery_home.png" />
                </section>

                <section>
                    <img src="images/jquery_home_zoom1.png" />
                </section>

                <section>
                    <h2>Premier exemple</h2>
                    <pre class="big"><code class="javascript"data-trim contenteditable>
$("button.continue").html("Next Step...")
                    </code></pre>
                </section>

                <section>
                    <h2>Document</h2>
                    <ul>
                        <li>getElementById</li>
                        <li>getElementsByTagName</li>
                        <li class="bigger">getElementsByClassName</li>
                        <li class="big">querySelector</li>
                        <li class="big">querySelectorAll</li>
                    </ul>
                </section>

                <section>
                    <h2 class="sensitive">document.querySelector</h2>
                    <browser-compat
                        ie="8"
                        ff="3.5"
                        cr="1"
                        sa="3.2"
                        op="10" />
                    <aside class="notes">
                        Cette méthode prend un sélecteur CSS et retourne le premier elt correspondant (ou null). Le support des sélecteurs dépend du support du moteur CSS, donc sous IE8 on est limité aux sélecteurs CSS2.1 et on n'a pas les pseudo-sélecteurs de jQuery (:has, :visible). Mais ça laisse pas mal de possibilités... Et donc cette méthode retourne un objet de type Element, que peut-on faire dessus ? Allons voir sur W3sch... le MDN ;)
                    </aside>
                </section>

                <section>
                    <img src="images/mdn.png" />
                </section>

                <section>
                    <img src="images/innerhtml.png" />
                </section>

                <section>
                    <pre class="big"><code class="javascript"data-trim contenteditable>
$("button.continue").html("Next Step...");
                    </code></pre>
                    <pre class="big"><code class="javascript"data-trim contenteditable>
document.querySelector("button.continue")
        .innerHTML = "Next Step...";
                    </code></pre>
                </section>

                <section>
                    <pre class="big"><code class="javascript"data-trim contenteditable>
$("button.continue").html("Next Step...");
                    </code></pre>
                    <pre class="big"><code class="javascript"data-trim contenteditable>
document.querySelector("button.continue")
        .innerHTML = "Next Step...";
                    </code></pre>
                    <p>Et que se passe t-il si le sélecteur ne correspond à aucun élément ?</p>
                    <aside class="notes">
                        Avec jQuery, il ne se passe rien... Par contre, avec la méthode DOM, on a une erreur ! Si on m'avais donné 1€ à chaque fois que j'ai perdu du temps à comprendre pourquoi mon code ne marchait pas alors que j'avais fait une typo dans mon sélecteur CSS, ma Ferrari serait garée dehors...
                    </aside>
                </section>

                <section>
                    <p class="error">
Uncaught TypeError: Cannot set property 'innerHTML' of null
                    </p>
                </section>

                <section>
                    <h2>Deuxième exemple</h2>
                    <pre><code class="javascript"data-trim contenteditable>
var hiddenBox = $("#banner-message");
$("#button-container button").on("click", function(event) {
  hiddenBox.show();
});
                    </code></pre>
                </section>

                <section>
                    <h2 class="sensitive">addEventListener</h2>
                    <pre><code class="javascript"data-trim contenteditable>
var hiddenBox = document.getElementByID("#banner-message");
document.querySelector("#button-container button")
        .addEventListener("click", function(event) {
            hiddenBox.setAttribute("style", "display: block");
        }, false);
                    </code></pre>
                    <aside class="notes">
                        le false correspond à l'argument 'useCapture', optionnel dans les browsers récents. si on utilise la capture, l'event va être déclenché sur les parents AVANT la cible de l'event ; si non, on fait de l'event bubbling, l'event va être déclenché en premier sur la cible.
                    </aside>
                </section>

                <section>
                    <h2 class="sensitive">addEventListener</h2>
                    <browser-compat
                        ie="9"
                        ff="1"
                        cr="1"
                        sa="1"
                        op="7" />
                    <aside class="notes">
                        Effectivement, IE8 (et les précédents) ont leur propres méthodes de gestion des events (attachEvent). Mais la bonne nouvelle, c'est qu'on trouve un polyfill complet sur le MDN, comme pour beaucoup de fonctions d'ailleurs.
                    </aside>
                </section>

                <section>
                    <img src="images/polyfill.png" />
                </section>

                <section>
                    <h2>Troisième exemple</h2>
                    <pre><code class="javascript" data-trim contenteditable>
$.ajax({
  url: "/api/getWeather",
  data: {
    zipcode: 97201
  },
  success: function(data) {
    $("#weather-temp").html("<strong>" + data + "</strong> degrees");
  }
});
                    </code></pre>
                </section>

                <section>
                    <h2 class="sensitive">XMLHttpRequest</h2>
                    <pre><code class="javascript" data-trim contenteditable>
var xhr = new XMLHttpRequest(),
    data = [],
    rawData = {
        zipcode: 97201
    };
for (var k in rawData) {
    data.push(encodeURIComponent(k) 
              + "=" + encodeURIComponent(rawData[k]));
}
xhr.open("GET", "/api/getWeather");
xhr.onload = function () {
    document.querySelector("#weather-temp")
            .innerHTML = "<strong>" + xhr.response 
                        + "</strong> degrees";
};
xhr.send(data.join("&"));
                    </code></pre>
                </section>

                <section>
                    <h2 class="sensitive">XMLHttpRequest et FormData</h2>
                    <pre><code class="javascript" data-trim contenteditable>
var xhr = new XMLHttpRequest(),
    data = new FormData(),
    rawData = {
        zipcode: 97201
    };
for (var k in rawData) {
    data.append(k, JSON.stringify(rawData[k]));
}
xhr.open("GET", "/api/getWeather");
xhr.onload = function () {
    document.querySelector("#weather-temp")
            .innerHTML = "<strong>" + xhr.response 
                        + "</strong> degrees";
};
xhr.send(data);
                    </code></pre>
                </section>

                <section>
                    <h2 class="sensitive">XMLHttpRequest et FormData</h2>
                    <pre><code class="javascript" data-trim contenteditable>
var xhr = new XMLHttpRequest(),
    data = new FormData(document.querySelector("#zipcode"));

xhr.open("GET", "/api/getWeather");
xhr.onload = function () {
    document.querySelector("#weather-temp")
            .innerHTML = "<strong>" + xhr.response 
                        + "</strong> degrees";
};
xhr.send(data);
                    </code></pre>
                </section>

                <section>
                    <h2 class="sensitive">FormData</h2>
                    <browser-compat
                        ie="10"
                        ff="4"
                        cr="7"
                        sa="12"
                        op="5" />
                    <aside class="notes">
                        
                    </aside>
                </section>

                <section>
                    <h2>Callback hell</h2>
                    <pre><code class="javascript" data-trim contenteditable>
$('#demo5').animo("rotate", { degrees:90 }, function(e) {
    e.element.animo( { animation: "flipOutX", keep: true } );
    $('#demo6').animo("rotate", { degrees:90 }, function(e) {

        e.element.animo( { animation: "flipOutY", keep: true } );
        $('#demo7').animo("rotate", { degrees:90 }, function(e) {

            e.element.animo( { animation: "flipOutX", keep: true } );
            $('#demo8').animo("rotate", { degrees:90 }, function(e){
                e.element.animo( { animation: "flipOutY", keep: true } );
            });
        });
    });
});
                    </code></pre>
                </section>

                <section>
                    <h2>jQuery deferreds</h2>
                    <pre><code class="javascript" data-trim contenteditable>
$.ajax({
    url: "/api/getWeather",
    data: {
        zipcode: 97201
    }
})
.done(function(data) {
    $("#weather-temp").html("<strong>" + data + "</strong> degrees");
})
.fail(function() {
    alert("error");
});
                    </code></pre>
                </section>

                <section>
                    <h2>Promises/A+</h2>
                    <pre><code class="javascript" data-trim contenteditable>
getTweetsFor("goldoraf", function (err, results) {
    ...
});
                    </code></pre>
                    <pre><code class="javascript" data-trim contenteditable>
var promiseForTweets = getTweetsFor("goldoraf");
promiseForTweets.then(function(results) {
    ...
});
                    </code></pre>
                    <pre><code class="javascript" data-trim contenteditable>
then(fulfilledHandler, errorHandler, progressHandler)
                    </code></pre>
                </section>

                <section>
                    <h2>Promises & XHR</h2>
                    <pre><code class="javascript" data-trim contenteditable>
function request(type, url, data) {
    return new Promise(function (resolve, reject) {
        var xhr = new XMLHttpRequest;
        xhr.addEventListener("error", reject);
        xhr.addEventListener("load", resolve);
        xhr.open("GET", url);
        xhr.send(null);
    });
}
                    </code></pre>
                </section>

                <section>
                    <h2>Résultat final</h2>
                    <pre><code class="javascript" data-trim contenteditable>
request("GET", "/api/getWeather", data)
.then(function(result) {
    document.querySelector("#weather-temp")
            .innerHTML = "<strong>" + result 
                        + "</strong> degrees";
});
                    </code></pre>
                </section>

                <section>
                    <h2 class="striked">Callback hell</h2>
                    <h2>Promise heaven</h2>
                    <pre><code class="javascript" data-trim contenteditable>
$('#demo5').animo("rotate", { degrees:90 })
.then(function(e) {
    e.element.animo({ animation: "flipOutX", keep: true });
    return $('#demo6').animo("rotate", { degrees:90 });
})
.then(function(e) {
    e.element.animo({ animation: "flipOutY", keep: true });
    return $('#demo7').animo("rotate", { degrees:90 });
})
.then(function(e) {
    e.element.animo({ animation: "flipOutX", keep: true });
    return $('#demo8').animo("rotate", { degrees:90 });
})
.then(function(e){
    e.element.animo({ animation: "flipOutY", keep: true });
});
                    </code></pre>
                    <aside class="notes">
                        En parlant d'animations, jQuery dispose justement d'outils pour cela.
                    </aside>
                </section>

                <section>
                    <h2>Animations</h2>
                    <pre><code class="javascript" data-trim contenteditable>
$("#book").animate({
    left: "+=50"
}, 5000, function() {
    // Animation complete.
});
                    </code></pre>
                    <aside class="notes">
                        Nous les avons tous utilisées, et pu constater qu'elles étaient loin d'être fluides. La raison en est que jQuery pour ses animations utilise les timers, en particulier la fonction setInterval qui permet d'exécuter un callback toutes les x ms. Or, je vous le rappelle, l'event loop d'un navigateur et de façon générale tout le code JS s'exécute dans un seul thread. Un. Seul. La conséquence est que les callbacks des events asynchrones, tels que les events d'UI et les timers, ne sont executés que lorsqu'il n'y a pas d'autre code à exécuter. Il suffit donc que le callback d'une requête Ajax par ex. soit executé au moment où le timer est censé déclencher le callback pour que celui-ci s'exécute en retard, d'où une sensation de lag accentuée par l'absence de synchro avec le rafraichissement des frames par le navigateur. Heureusement, les navigateurs récents nous proposent une solution nous permettant de synchroniser nos animations avec le rafraîchissement de l'écran.
                    </aside>
                </section>

                <section>
                    <h2 class="sensitive">requestAnimationFrame</h2>
                    <browser-compat
                        ie="10"
                        ff="4"
                        cr="10"
                        sa="6"
                        op="15" />

                </section>

                <section>
                    <h2 class="sensitive">requestAnimationFrame</h2>
                    <pre><code class="javascript" data-trim contenteditable>
var start = null,
    d = document.getElementById("#book");

function step(timestamp) {
    var progress;
    if (start === null) start = timestamp;
    progress = timestamp - start;
    d.style.left = Math.min(progress/100, 50) + "px";
    if (progress < 5000) {
        requestAnimationFrame(step);
    }
}

requestAnimationFrame(step);
                    </code></pre>
                    <a href="http://www.html5rocks.com/en/tutorials/speed/rendering/">http://www.html5rocks.com/en/tutorials/speed/rendering/</a>
                    <aside class="notes">
                         Attention aux vendor-prefix ! requestAnimationFrame indique au navigateur qu'il doit appeller un callback avant le prochain repaint. Ce callback nous permet de mettre à jour l'état de notre animation. Et cela permet donc de rester synchro avec le refresh rate du navigateur, et ainsi d'avoir une animation plus fluide. Sur ce sujet, je vous recommande la lecture de l'article en lien.
                         Remarque : utiliser la propriété left pour l'animation comme ici dans l'exemple n'est pas optimal, car cela ne permet pas un positionnement "sub-pixelique". Et de manière générale, une animation drivée par JS qui a beaucoup d'autres choses à faire dans une appli web moderne n'est pas optimal. L'idéal serait de laisser le navigateur gérer ce genre de choses, car il a accès au GPU et peut donc optimiser les animations bien mieux que nous. Ce qui me permet d'introduire les animations CSS3. Il y a 2 façons d'en faire : les transitions et les animations.
                    </aside>
                </section>

                <section>
                    <h2>Transitions CSS3</h2>
                    <table class="demo">
                        <tr>
                            <td class="code">
                                <pre><code class="css" data-trim contenteditable>
button.foo {
    font-size: 40px;
    background: #C9C9C9;
    
    transition-property: background;
    -moz-transition-property: background;
    -webkit-transition-property: background;
    -o-transition-property: background;
    
    transition-duration: 500ms;
    -webkit-transition-duration: 500ms;
}
button.foo:hover {
    background: #959595;
    color: #FFF;
}
                                </code></pre>
                            </td>
                            <td class="sample">
                                <style>
button.foo {
    font-size: 40px;
    background: #C9C9C9;
    
    transition-property: background;
    -moz-transition-property: background;
    -webkit-transition-property: background;
    -o-transition-property: background;
    
    transition-duration: 500ms;
    -webkit-transition-duration: 500ms;
}
button.foo:hover {
    background: #959595;
    color: #FFF;
}
                                </style>
                                <button class="foo">Hello</button>
                            </td>
                        </tr>
                    </table>
                    <aside class="notes">
                        On a besoin de définir seulement 2 propriétés : transition-property & duration. Attention aux vendor prefixes !
                    </aside>
                </section>

                <section>
                    <h2>Animations CSS3</h2>
                    <table class="demo">
                        <tr>
                            <td class="code">
                                <pre><code class="css" data-trim contenteditable>
@keyframes 'my-animation' {
    0% { background: #C9C9C9; }
    50% { background: #61BE50; }
    100% { background: #C9C9C9; }
}
button.bar:hover {
    background: #959595;
    color: #FFF;
    
    animation-name: 'my-animation';
    animation-duration: 2s;
    animation-iteration-count: infinite;
}
                                </code></pre>
                            </td>
                            <td class="sample">
                                <style>
@keyframes 'bg-animation' {
    0% {
        background: #C9C9C9;
    }
    50% {
        background: #61BE50;
    }
    100% {
        background: #C9C9C9;
    }
}
@-webkit-keyframes 'bg-animation' {
    0% {
        background: #C9C9C9;
    }
    50% {
        background: #61BE50;
    }
    100% {
        background: #C9C9C9;
    }
}
button.bar {
    font-size: 40px;
    background: #C9C9C9;    
}
button.bar:hover {
    background: #959595;
    color: #FFF;
    
    animation-name: 'bg-animation';
    animation-duration: 2s;
    animation-iteration-count: infinite;
    
    -webkit-animation-name: 'bg-animation';
    -webkit-animation-duration: 2s;
    -webkit-animation-iteration-count: infinite;
    
}
                                </style>
                                <button class="bar">Hello</button>
                            </td>
                        </tr>
                    </table>
                    <aside class="notes">
                        Les animations CSS permettent, elles, de définir les valeurs de différentes propriétés CSS à certains moments de l'animation, d'où la possibilité de créer des anims plus complexes. Cependant, les animations en pur CSS ne peuvent être interrompues et sont difficilement synchronisables. Elles sont donc parfaites pour des effets simples (comme sur un bouton), mais on va avoir besoin de JS pour coordonner différentes animations, et surtout pour détecter la fin d'une animation.
                    </aside>
                </section>

                <section>
                    <h2 class="sensitive">transitionend</h2>
                    <pre><code class="javascript" data-trim contenteditable>
function whichTransitionEvent(el){
    var t,
        transitions = {
          'transition':'transitionend',
          'OTransition':'oTransitionEnd',
          'MozTransition':'transitionend',
          'WebkitTransition':'webkitTransitionEnd'
        }

    for (t in transitions) {
        if (el.style[t] !== undefined) {
            return transitions[t];
        }
    }
}
                    </code></pre>
                    <aside class="notes">
                        A cause des vendor-prefixes, nous avons besoin d'une fonction dans ce genre pour déterminer quel event écouter.
                    </aside>
                </section>

                <section>
                    <h2 class="sensitive">transitionend</h2>
                    <pre><code class="javascript" data-trim contenteditable>
var transitionEnd = whichTransitionEvent(element);
element.addEventListener(transitionEnd, function(event) {
    // on déclenche l'animation suivante !
    element.classList.add('expand');
});
                    </code></pre>
                    <aside class="notes">
                        On peut ainsi avec cet event chaîner les animations, et à l'aide d'un soupçon de Promises, construire une librairie dont l'utilisation pourrait ressembler à l'exemple précédent... Je vous recommande chaudement animate.css...
                        Bien, nous avons parlé de beaucoup de choses, mais il reste un sujet sur lequel je souhaiterais vous entretenir...
                    </aside>
                </section>
                
                <section>
                    <img class="raw" src="images/jquery_ui.png" />
                    <aside class="notes">
                        Bla bla bla...
                    </aside>
                </section>

                <section>
                    <h2>Web components</h2>
                    <h3>Un modèle de composant pour le web</h3>
                    <img src="images/webcomponents.png" />
                    <aside class="notes">
                        Ce modèle est constitué de 5 concepts, qui seront à terme implémentés nativement dans les navigateurs.
                    </aside>
                </section>

                <section>
                    <h2>Templates</h2>
                    <pre><code class="html" data-trim contenteditable>
&lt;template id="commentTemplate"&gt;
    &lt;div&gt;
        &lt;img src=""&gt;
        &lt;div class="comment-text"&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/template&gt;
                    </code></pre>
                    <pre><code class="javascript" data-trim contenteditable>
var tpl = document.querySelector("#commentTemplate");
tpl.content.querySelector(".comment-text").innerHTML = ...;
document.body.appendChild(tpl.content.cloneNode(true));
                    </code></pre>
                    <aside class="notes">
                        Une balise template fait son apparition, le HTML qu'elle contient est parsé mais pas affiché. S'il contient du script, il ne sera pas executé. On peut récuperer le contenu du template en JS, le manipuler puis l'insérer dans le DOM.
                    </aside>
                </section>

                <section>
                    <h2>Decorators</h2>
                    <pre><code class="html" data-trim contenteditable>
&lt;decorator id="modal-controls"&gt;
   &lt;template&gt;
      &lt;section&gt;
         &lt;header&gt;
            &lt;a id="toggle" href="#"&gt;Maximize&lt;/a&gt;
            &lt;a id="close" href="#"&gt;Close&lt;/a&gt;
         &lt;/header&gt;
         &lt;content&gt;&lt;/content&gt;
      &lt;/section&gt;
   &lt;/template&gt;
&lt;/decorator&gt;
                    </code></pre>
                    <pre><code class="css" data-trim contenteditable>
.my-modal {
   decorator: url(#modal-controls);
}
                    </code></pre>
                    <aside class="notes">
                        Les décorateurs sont destinés à améliorer ou modifier la présentation d'un élément existant (description de l'exemple). La balise content est un point d'insertion pour l'élément original. Notez toutefois que c'est le seul concept qui n'a pas encore été spécifié officiellement par le W3C, l'exemple proposé n'est qu'un concept en cours de discussion...
                    </aside>
                </section>

                <section>
                    <h2>Custom elements</h2>
                    <pre><code class="html" data-trim contenteditable>
&lt;element extends="button" name="my-button" attributes="foo bar"&gt;
    &lt;template&gt;...&lt;/template&gt;
    &lt;script&gt;...&lt;/script&gt;
&lt;/element&gt;
                    </code></pre>
                    <aside class="notes">
                        L'introduction des custom elements permet aux développeurs de créer leurs propres types d'éléments DOM. Ils peuvent contenir du JS, et ainsi maintenir un état et exposer une API accessible via le DOM.
                    </aside>
                </section>

                <section>
                    <h2>Shadow DOM</h2>
                    <h2>HTML imports</h2>
                    <pre><code class="html" data-trim contenteditable>
&lt;link rel="import" href="my-component.html"&gt;
                    </code></pre>
                    <aside class="notes">
                        L'objectif du Shadow DOM est de permettre l'encapsulation en cachant des sous-arbres du DOM. Le concept existe depuis longtemps, la balise vidéo est d'ailleurs implémentée de cette façon, mais elle sera désormais accessible aux devs web. Les imports HTML permettent simplement de charger ses web components depuis un fichier externe.

                        Bon maintenant vous allez me dire "c'est génial tout ça, mais si ça ne marche dans aucun navigateur...". Il existe 2 librairies, Polymer et X-Tag, qui vous donnent accès à ces possibilités dès aujourd'hui. Ils se sont d'ailleurs récemment mis d'accord pour conjuguer leurs efforts et se baser sur la même couche de polyfills.
                    </aside>
                </section>

                <section>
                    <h2>Web components</h2>
                    <h3>Avec X-Tag</h3>
                    <browser-compat
                        ie="9"
                        ff="5"
                        cr="4"
                        sa="4"
                        op="11" />
                    <aside class="notes">
                        
                    </aside>
                </section>

                <section>
                    <h2>Un exemple ?</h2>
                    <pre><code class="html" data-trim contenteditable>
&lt;browser-compat
    ie="9"
    ff="5"
    cr="4"
    sa="4"
    op="11" /&gt;
                    </code></pre>
                    <aside class="notes">
                        
                    </aside>
                </section>

                <section>
                    <h2>Un exemple ?</h2>
                    <pre><code class="html" data-trim contenteditable>
&lt;polymer-element name="browser-compat"
    attributes="ie ff cr sa op"&gt;
    &lt;template&gt;
        &lt;style&gt;...&lt;/style&gt;
        &lt;table class="browser-compat"&gt;
            &lt;tr&gt;
                &lt;td&gt;&lt;img src="images/ie.png" /&gt;&lt;/td&gt;
                ...
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td class="{{ie_class}}"&gt;&gt;= {{ie}}&lt;/td&gt;
                ...
            &lt;/tr&gt;
        &lt;/table&gt;
    &lt;/template&gt;
    &lt;script&gt;...&lt;/script&gt;
&lt;/polymer-element&gt;
                    </code></pre>
                    <aside class="notes">
                        
                    </aside>
                </section>

                <section>
                    <h2>Un exemple ?</h2>
                    <pre><code class="javascript" data-trim contenteditable>
Polymer('browser-compat', {
    created: function() {
        switch(parseInt(this.ie)) {
            case 10:
                this.ie_class = 'red';
                break;
            case 9:
                this.ie_class = 'yellow';
                break;
            default:
                this.ie_class = 'green';
                break;
        }
    }
});
                    </code></pre>
                    <aside class="notes">
                        
                    </aside>
                </section>

                <section>
                    <h2>Codez pour le futur !</h2>
                    <img src="images/pluto.jpg" />
                    <img src="images/titan.jpg" />
                    <p><small>Copyright Steve Thomas Art & Illustration, LLC</small></p>
                    <aside class="notes">
                        
                    </aside>
                </section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
